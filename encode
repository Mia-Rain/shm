#!/bin/sh
nl='
'
space=' '
n=0; while IFS= read -r p || [ "$p" ]; do
  [ "$n" -eq 0 -a "$p" = "#!/bin/sh" ] && p="#!/usr/bin/env shm" 
  IFS=" "; for i in $p; do
    [ "${i#\$(}" != "$i" ] && {
      i="${i#'$('}"
    }
    [ "${i%)}" != "$i" ] && {
      i="${i%)}"
    }
    case "${i}" in
      '#')     break;;
      'while') p="${p%%"${i}"*}w${p##*"${i}"}";;
      'until') p="${p%%"${i}"*}u${p##*"${i}"}";;
      'done')  p="${p%%"${i}"*}n${p##*"${i}"}";;
      'for')   p="${p%%"${i}"*}f${p##*"${i}"}"; for=1;;
      'do')    p="${p%%"${i}"*}d${p##*"${i}"}";;
      'in')    p="${p%%"${i}"*}i${p##*"${i}"}";;
      # using a letter for in can cause issues
      # this is solved with syntax changes; see README
      'case')  p="${p%%"${i}"*}c${p##*"${i}"}";;
      'esac')  p="${p%%"${i}"*}s${p##*"${i}"}";;
      'read')  p="${p%%"${i}"*}r${p##*"${i}"}";;
      'echo')  p="${p%%"${i}"*}e${p##*"${i}"}";;
      'printf')p="${p%%"${i}"*}p${p##*"${i}"}";;
      'EOF')   p="${p%%"${i}"*}o${p##*"${i}"}";;
      *) [ "$for" ] && {
        p="${p%%"${i}"*}${i:+\$"$i"}${space}${p##*"${i}${space}"}"
        unset for # this solves previous issues with in
       } ;;
    esac # default to letter shorthand to readability
  done
  unset for sub esub
  printf '%s' "$p$nl"
  : $((n+=1))
done
